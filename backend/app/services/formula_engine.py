"""
FormulaEngine - Core Trading Formula Evaluation Engine

This module contains the main FormulaEngine class responsible for:
- Evaluating trading formulas for subscribed users
- Generating entry/exit signals based on market data
- Auto-executing trades or sending notifications
- Managing formula execution lifecycle
"""

import asyncio
import json
import logging
from datetime import datetime, timezone, timedelta
from decimal import Decimal
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass
from enum import Enum

from sqlalchemy.orm import Session
from celery import Celery

from app.core.database import get_db_session
from app.models import User, Formula, Subscription, Trade, BrokerAccount, Notification
from app.services.market_data_service import MarketDataService
from app.services.broker_service import BrokerService
from app.services.notification_service import NotificationService
from app.utils.calculations import calculate_position_size, calculate_risk_metrics
from app.utils.validators import validate_signal, validate_market_hours

# Configure logging
logger = logging.getLogger(__name__)


class SignalType(str, Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    EXIT_LONG = "exit_long"
    EXIT_SHORT = "exit_short"


class ExecutionMode(str, Enum):
    """Formula execution modes."""
    AUTO = "auto"
    NOTIFICATION_ONLY = "notification_only"
    MANUAL = "manual"
    ALERT_ONLY = "alert_only"


@dataclass
class FormulaEvaluationResult:
    """Result of formula evaluation."""
    signal: SignalType
    confidence: float
    price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[int] = None
    error: Optional[str] = None


@dataclass
class ExecutionResult:
    """Result of trade execution."""
    success: bool
    trade_id: Optional[str] = None
    execution_price: Optional[float] = None
    execution_time: Optional[datetime] = None
    error: Optional[str] = None
    requires_approval: bool = False
    notification_sent: bool = False
    risk_warnings: Optional[List[str]] = None


@dataclass
class TradeSignal:
    """Trading signal data."""
    symbol: str
    side: str
    quantity: int
    price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    confidence: float = 0.0
    formula_id: Optional[str] = None


@dataclass
class MarketData:
    """Market data structure for formula evaluation."""
    symbol: str
    price: Decimal
    volume: int
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    indicators: Dict[str, Any] = None


@dataclass
class TradingSignal:
    """Trading signal generated by formula evaluation."""
    formula_id: str
    user_id: str
    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    price: Decimal
    quantity: Optional[int] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    metadata: Dict[str, Any] = None
    timestamp: datetime = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now(timezone.utc)


class FormulaEngine:
    """
    Core engine for evaluating trading formulas and generating signals.
    
    This class handles the complete lifecycle of formula evaluation:
    1. Fetch active subscriptions for all users
    2. Retrieve market data for required symbols
    3. Evaluate formulas with market data
    4. Generate and validate trading signals
    5. Execute trades or send notifications based on user preferences
    6. Log all actions and results
    """

    def __init__(
        self,
        market_data_service: MarketDataService,
        broker_service: BrokerService,
        notification_service: NotificationService,
        celery_app: Optional[Celery] = None
    ):
        """
        Initialize the FormulaEngine.
        
        Args:
            market_data_service: Service for fetching market data
            broker_service: Service for executing trades
            notification_service: Service for sending notifications
            celery_app: Celery app for background tasks
        """
        self.market_data_service = market_data_service
        self.broker_service = broker_service
        self.notification_service = notification_service
        self.celery_app = celery_app
        
        # Configuration
        self.min_confidence_threshold = 0.6
        self.max_position_size_percent = 0.1  # 10% of portfolio
        self.default_stop_loss_percent = 0.02  # 2%
        self.default_take_profit_percent = 0.04  # 4%
        self.is_cleanup_complete = False
        
        logger.info("FormulaEngine initialized")

    async def evaluate_all_formulas(self) -> Dict[str, Any]:
        """
        Main entry point for evaluating all active formulas.
        
        This method orchestrates the complete evaluation process:
        1. Fetch all active subscriptions
        2. Group by user and formula
        3. Evaluate each formula
        4. Process generated signals
        
        Returns:
            Dict containing evaluation results and statistics
        """
        start_time = datetime.now(timezone.utc)
        logger.info("Starting formula evaluation cycle")
        
        try:
            # Get database session
            db = get_db_session()
            
            # Fetch active subscriptions
            active_subscriptions = await self._fetch_active_subscriptions(db)
            logger.info(f"Found {len(active_subscriptions)} active subscriptions")
            
            if not active_subscriptions:
                logger.info("No active subscriptions found")
                return self._create_evaluation_result(start_time, 0, 0, 0, 0)
            
            # Group subscriptions by user
            user_subscriptions = self._group_subscriptions_by_user(active_subscriptions)
            
            # Evaluate formulas for each user
            total_signals = 0
            total_executions = 0
            total_notifications = 0
            total_errors = 0
            
            for user_id, subscriptions in user_subscriptions.items():
                try:
                    user_result = await self._evaluate_user_formulas(
                        db, user_id, subscriptions
                    )
                    total_signals += user_result['signals_generated']
                    total_executions += user_result['executions']
                    total_notifications += user_result['notifications']
                    total_errors += user_result['errors']
                    
                except Exception as e:
                    logger.error(f"Error evaluating formulas for user {user_id}: {e}")
                    total_errors += 1
            
            db.close()
            
            result = self._create_evaluation_result(
                start_time, total_signals, total_executions, 
                total_notifications, total_errors
            )
            
            logger.info(f"Formula evaluation cycle completed: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Critical error in formula evaluation: {e}")
            raise

    async def _fetch_active_subscriptions(self, db: Session) -> List[Subscription]:
        """
        Fetch all active subscriptions from the database.
        
        Args:
            db: Database session
            
        Returns:
            List of active subscriptions
        """
        subscriptions = db.query(Subscription).join(Formula).join(User).filter(
            Subscription.status == 'active',
            Formula.status == 'published',
            User.is_active == True
        ).all()
        
        return subscriptions

    def _group_subscriptions_by_user(self, subscriptions: List[Subscription]) -> Dict[str, List[Subscription]]:
        """
        Group subscriptions by user ID.
        
        Args:
            subscriptions: List of subscriptions
            
        Returns:
            Dictionary mapping user_id to list of subscriptions
        """
        user_subscriptions = {}
        for subscription in subscriptions:
            user_id = subscription.user_id
            if user_id not in user_subscriptions:
                user_subscriptions[user_id] = []
            user_subscriptions[user_id].append(subscription)
        
        return user_subscriptions

    async def _evaluate_user_formulas(
        self, 
        db: Session, 
        user_id: str, 
        subscriptions: List[Subscription]
    ) -> Dict[str, int]:
        """
        Evaluate all formulas for a specific user.
        
        Args:
            db: Database session
            user_id: User ID
            subscriptions: List of user's subscriptions
            
        Returns:
            Dictionary with evaluation statistics
        """
        logger.info(f"Evaluating formulas for user {user_id}")
        
        signals_generated = 0
        executions = 0
        notifications = 0
        errors = 0
        
        # Get user's broker accounts
        broker_accounts = db.query(BrokerAccount).filter(
            BrokerAccount.user_id == user_id,
            BrokerAccount.is_active == True,
            BrokerAccount.is_connected == True
        ).all()
        
        if not broker_accounts:
            logger.warning(f"No active broker accounts found for user {user_id}")
            return {'signals_generated': 0, 'executions': 0, 'notifications': 0, 'errors': 1}
        
        # Get required symbols for all formulas
        required_symbols = await self._get_required_symbols(subscriptions)
        
        # Fetch market data
        market_data = await self._fetch_market_data(required_symbols)
        
        # Evaluate each formula
        for subscription in subscriptions:
            try:
                formula = subscription.formula
                signals = await self._evaluate_formula(
                    db, user_id, formula, market_data, broker_accounts
                )
                
                signals_generated += len(signals)
                
                # Process each signal
                for signal in signals:
                    if signal.confidence >= self.min_confidence_threshold:
                        execution_result = await self._process_signal(
                            db, user_id, signal, broker_accounts
                        )
                        
                        if execution_result.success:
                            executions += 1
                        else:
                            notifications += 1
                    else:
                        logger.info(f"Signal confidence too low: {signal.confidence}")
                        notifications += 1
                        
            except Exception as e:
                logger.error(f"Error evaluating formula {subscription.formula_id}: {e}")
                errors += 1
        
        return {
            'signals_generated': signals_generated,
            'executions': executions,
            'notifications': notifications,
            'errors': errors
        }

    async def _get_required_symbols(self, subscriptions: List[Subscription]) -> List[str]:
        """
        Extract required symbols from formula parameters.
        
        Args:
            subscriptions: List of subscriptions
            
        Returns:
            List of unique symbols required
        """
        symbols = set()
        
        for subscription in subscriptions:
            formula = subscription.formula
            try:
                parameters = json.loads(formula.parameters or '{}')
                formula_symbols = parameters.get('symbols', [])
                if isinstance(formula_symbols, list):
                    symbols.update(formula_symbols)
                elif isinstance(formula_symbols, str):
                    symbols.add(formula_symbols)
            except json.JSONDecodeError:
                logger.warning(f"Invalid parameters JSON for formula {formula.id}")
        
        return list(symbols)

    async def _fetch_market_data(self, symbols: List[str]) -> Dict[str, MarketData]:
        """
        Fetch market data for required symbols.
        
        Args:
            symbols: List of symbols to fetch
            
        Returns:
            Dictionary mapping symbol to MarketData
        """
        market_data = {}
        
        for symbol in symbols:
            try:
                data = await self.market_data_service.get_latest_data(symbol)
                market_data[symbol] = MarketData(
                    symbol=symbol,
                    price=data['price'],
                    volume=data['volume'],
                    timestamp=data['timestamp'],
                    open=data['open'],
                    high=data['high'],
                    low=data['low'],
                    close=data['close'],
                    indicators=data.get('indicators', {})
                )
            except Exception as e:
                logger.error(f"Error fetching market data for {symbol}: {e}")
        
        return market_data

    async def _evaluate_formula(
        self,
        db: Session,
        user_id: str,
        formula: Formula,
        market_data: Dict[str, MarketData],
        broker_accounts: List[BrokerAccount]
    ) -> List[TradingSignal]:
        """
        Evaluate a single formula and generate trading signals.
        
        Args:
            db: Database session
            user_id: User ID
            formula: Formula to evaluate
            market_data: Market data for required symbols
            broker_accounts: User's broker accounts
            
        Returns:
            List of generated trading signals
        """
        try:
            # Parse formula code and parameters
            formula_code = formula.formula_code
            parameters = json.loads(formula.parameters or '{}')
            
            # Create evaluation context
            context = {
                'user_id': user_id,
                'formula_id': formula.id,
                'market_data': market_data,
                'parameters': parameters,
                'broker_accounts': broker_accounts
            }
            
            # Execute formula (this would call the actual formula evaluation)
            signals = await self._execute_formula_code(formula_code, context)
            
            # Validate and enhance signals
            validated_signals = []
            for signal in signals:
                if validate_signal(signal):
                    enhanced_signal = await self._enhance_signal(signal, context)
                    validated_signals.append(enhanced_signal)
            
            return validated_signals
            
        except Exception as e:
            logger.error(f"Error evaluating formula {formula.id}: {e}")
            return []

    async def _execute_formula_code(
        self, 
        formula_code: str, 
        context: Dict[str, Any]
    ) -> List[TradingSignal]:
        """
        Execute formula code and generate signals.
        
        This is a simplified implementation. In production, you would:
        1. Parse and validate the formula code
        2. Execute it in a sandboxed environment
        3. Return structured signals
        
        Args:
            formula_code: Formula code to execute
            context: Evaluation context
            
        Returns:
            List of generated signals
        """
        # This is a mock implementation
        # In production, you would implement a proper formula execution engine
        
        signals = []
        
        # Mock signal generation based on formula type
        if 'momentum' in formula_code.lower():
            signals = await self._generate_momentum_signals(context)
        elif 'mean_reversion' in formula_code.lower():
            signals = await self._generate_mean_reversion_signals(context)
        else:
            signals = await self._generate_default_signals(context)
        
        return signals

    async def _generate_momentum_signals(self, context: Dict[str, Any]) -> List[TradingSignal]:
        """Generate momentum-based trading signals."""
        signals = []
        market_data = context['market_data']
        
        for symbol, data in market_data.items():
            # Simple momentum logic (mock)
            if data.price > data.close * Decimal('1.02'):  # 2% price increase
                signal = TradingSignal(
                    formula_id=context['formula_id'],
                    user_id=context['user_id'],
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    confidence=0.8,
                    price=data.price,
                    metadata={'strategy': 'momentum'}
                )
                signals.append(signal)
        
        return signals

    async def _generate_mean_reversion_signals(self, context: Dict[str, Any]) -> List[TradingSignal]:
        """Generate mean reversion trading signals."""
        signals = []
        market_data = context['market_data']
        
        for symbol, data in market_data.items():
            # Simple mean reversion logic (mock)
            if data.price < data.close * Decimal('0.98'):  # 2% price decrease
                signal = TradingSignal(
                    formula_id=context['formula_id'],
                    user_id=context['user_id'],
                    symbol=symbol,
                    signal_type=SignalType.BUY,
                    confidence=0.7,
                    price=data.price,
                    metadata={'strategy': 'mean_reversion'}
                )
                signals.append(signal)
        
        return signals

    async def _generate_default_signals(self, context: Dict[str, Any]) -> List[TradingSignal]:
        """Generate default trading signals."""
        return []

    async def _enhance_signal(
        self, 
        signal: TradingSignal, 
        context: Dict[str, Any]
    ) -> TradingSignal:
        """
        Enhance signal with additional information like position sizing.
        
        Args:
            signal: Original signal
            context: Evaluation context
            
        Returns:
            Enhanced signal
        """
        # Calculate position size
        broker_accounts = context['broker_accounts']
        if broker_accounts:
            account = broker_accounts[0]  # Use first account
            portfolio_value = account.portfolio_value or Decimal('10000')
            
            # Calculate position size based on risk
            position_size = calculate_position_size(
                portfolio_value,
                signal.price,
                self.max_position_size_percent
            )
            signal.quantity = int(position_size)
            
            # Add stop loss and take profit
            signal.stop_loss = signal.price * (1 - self.default_stop_loss_percent)
            signal.take_profit = signal.price * (1 + self.default_take_profit_percent)
        
        return signal

    async def _process_signal(
        self,
        db: Session,
        user_id: str,
        signal: TradingSignal,
        broker_accounts: List[BrokerAccount]
    ) -> ExecutionResult:
        """
        Process a trading signal (execute or notify).
        
        Args:
            db: Database session
            user_id: User ID
            signal: Trading signal to process
            broker_accounts: User's broker accounts
            
        Returns:
            Execution result
        """
        try:
            # Check if user has auto-execution enabled
            user = db.query(User).filter(User.id == user_id).first()
            execution_mode = getattr(user, 'execution_mode', ExecutionMode.NOTIFICATION_ONLY)
            
            if execution_mode == ExecutionMode.AUTO:
                # Auto-execute trade
                result = await self._execute_trade(db, signal, broker_accounts)
                
                if result.success:
                    await self._log_trade_execution(db, signal, result)
                else:
                    await self._send_execution_notification(db, signal, result.error_message)
                
                return result
            else:
                # Send notification only
                await self._send_signal_notification(db, signal)
                return ExecutionResult(success=False, error_message="Notification sent")
                
        except Exception as e:
            logger.error(f"Error processing signal: {e}")
            return ExecutionResult(success=False, error_message=str(e))

    async def _execute_trade(
        self,
        db: Session,
        signal: TradingSignal,
        broker_accounts: List[BrokerAccount]
    ) -> ExecutionResult:
        """
        Execute a trade through the broker service.
        
        Args:
            db: Database session
            signal: Trading signal
            broker_accounts: Available broker accounts
            
        Returns:
            Execution result
        """
        try:
            # Select appropriate broker account
            broker_account = broker_accounts[0]  # Use first account
            
            # Check market hours
            if not validate_market_hours():
                return ExecutionResult(
                    success=False,
                    error_message="Market is closed"
                )
            
            # Execute trade through broker service
            trade_result = await self.broker_service.execute_trade(
                broker_account=broker_account,
                symbol=signal.symbol,
                side=signal.signal_type.value,
                quantity=signal.quantity,
                order_type='market',
                price=signal.price
            )
            
            if trade_result.success:
                # Create trade record in database
                trade = Trade(
                    user_id=signal.user_id,
                    formula_id=signal.formula_id,
                    broker_account_id=broker_account.id,
                    symbol=signal.symbol,
                    side=signal.signal_type.value,
                    quantity=signal.quantity,
                    order_type='market',
                    price=signal.price,
                    status='filled',
                    filled_quantity=signal.quantity,
                    average_fill_price=trade_result.execution_price,
                    broker_order_id=trade_result.broker_order_id,
                    filled_at=datetime.now(timezone.utc)
                )
                
                db.add(trade)
                db.commit()
                
                return ExecutionResult(
                    success=True,
                    trade_id=str(trade.id),
                    broker_order_id=trade_result.broker_order_id,
                    execution_price=trade_result.execution_price,
                    execution_time=datetime.now(timezone.utc)
                )
            else:
                return ExecutionResult(
                    success=False,
                    error_message=trade_result.error_message
                )
                
        except Exception as e:
            logger.error(f"Error executing trade: {e}")
            return ExecutionResult(success=False, error_message=str(e))

    async def _send_signal_notification(self, db: Session, signal: TradingSignal) -> None:
        """Send notification for a trading signal."""
        try:
            notification = Notification(
                user_id=signal.user_id,
                type='formula_trigger',
                title=f'Trading Signal: {signal.symbol}',
                message=f'{signal.signal_type.value.upper()} signal for {signal.symbol} at ${signal.price}',
                related_formula_id=signal.formula_id,
                metadata=json.dumps(signal.metadata or {})
            )
            
            db.add(notification)
            db.commit()
            
            # Send push notification
            await self.notification_service.send_push_notification(
                user_id=signal.user_id,
                title=notification.title,
                message=notification.message,
                data={'signal': signal.__dict__}
            )
            
        except Exception as e:
            logger.error(f"Error sending signal notification: {e}")

    async def _send_execution_notification(
        self, 
        db: Session, 
        signal: TradingSignal, 
        error_message: str
    ) -> None:
        """Send notification for execution failure."""
        try:
            notification = Notification(
                user_id=signal.user_id,
                type='system_alert',
                title='Trade Execution Failed',
                message=f'Failed to execute {signal.signal_type.value} order for {signal.symbol}: {error_message}',
                related_formula_id=signal.formula_id
            )
            
            db.add(notification)
            db.commit()
            
        except Exception as e:
            logger.error(f"Error sending execution notification: {e}")

    async def _log_trade_execution(
        self, 
        db: Session, 
        signal: TradingSignal, 
        result: ExecutionResult
    ) -> None:
        """Log successful trade execution."""
        logger.info(
            f"Trade executed successfully: "
            f"User={signal.user_id}, Symbol={signal.symbol}, "
            f"Side={signal.signal_type.value}, Price={result.execution_price}"
        )

    def _create_evaluation_result(
        self,
        start_time: datetime,
        signals_generated: int,
        executions: int,
        notifications: int,
        errors: int
    ) -> Dict[str, Any]:
        """Create evaluation result summary."""
        end_time = datetime.now(timezone.utc)
        duration = (end_time - start_time).total_seconds()
        
        return {
            'start_time': start_time.isoformat(),
            'end_time': end_time.isoformat(),
            'duration_seconds': duration,
            'signals_generated': signals_generated,
            'executions': executions,
            'notifications': notifications,
            'errors': errors,
            'success_rate': (executions + notifications) / max(signals_generated, 1)
        }

    async def evaluate_single_formula(
        self, 
        user_id: str, 
        formula_id: str
    ) -> Dict[str, Any]:
        """
        Evaluate a single formula for a specific user.
        
        This method is useful for testing and manual evaluation.
        
        Args:
            user_id: User ID
            formula_id: Formula ID
            
        Returns:
            Evaluation result
        """
        logger.info(f"Evaluating single formula {formula_id} for user {user_id}")
        
        try:
            db = get_db_session()
            
            # Get subscription
            subscription = db.query(Subscription).filter(
                Subscription.user_id == user_id,
                Subscription.formula_id == formula_id,
                Subscription.status == 'active'
            ).first()
            
            if not subscription:
                return {'error': 'No active subscription found'}
            
            # Get broker accounts
            broker_accounts = db.query(BrokerAccount).filter(
                BrokerAccount.user_id == user_id,
                BrokerAccount.is_active == True
            ).all()
            
            # Evaluate formula
            result = await self._evaluate_user_formulas(
                db, user_id, [subscription]
            )
            
            db.close()
            return result
            
        except Exception as e:
            logger.error(f"Error evaluating single formula: {e}")
            return {'error': str(e)}

    def get_engine_status(self) -> Dict[str, Any]:
        """Get current engine status and configuration."""
        return {
            'min_confidence_threshold': self.min_confidence_threshold,
            'max_position_size_percent': self.max_position_size_percent,
            'default_stop_loss_percent': self.default_stop_loss_percent,
            'default_take_profit_percent': self.default_take_profit_percent,
            'services_connected': {
                'market_data': self.market_data_service is not None,
                'broker': self.broker_service is not None,
                'notification': self.notification_service is not None
            }
        }

    async def evaluate_formula(self, formula: Formula, symbol: str) -> FormulaEvaluationResult:
        """
        Evaluate a single formula for a specific symbol.
        
        Args:
            formula: Formula to evaluate
            symbol: Trading symbol
            
        Returns:
            FormulaEvaluationResult with signal and confidence
        """
        try:
            logger.info(f"Evaluating formula {formula.name} for symbol {symbol}")
            
            # Get market data
            market_data_dict = await self.market_data_service.get_real_time_quote(symbol)
            indicators = await self.market_data_service.calculate_technical_indicators(symbol)
            
            # Parse formula logic
            formula_code = json.loads(formula.formula_code)
            parameters = json.loads(formula.parameters) if formula.parameters else {}
            
            # Evaluate formula logic
            signal = await self._evaluate_formula_logic(formula_code, indicators, parameters)
            
            # Calculate confidence based on signal strength
            confidence = self._calculate_confidence(signal, indicators)
            
            # Apply risk management
            price = Decimal(str(market_data_dict.get('price', 0)))
            stop_loss, take_profit = self._calculate_risk_levels(price, parameters)
            position_size = self._calculate_position_size(price, parameters)
            
            return FormulaEvaluationResult(
                signal=signal,
                confidence=confidence,
                price=float(price),
                stop_loss=stop_loss,
                take_profit=take_profit,
                position_size=position_size
            )
            
        except Exception as e:
            logger.error(f"Error evaluating formula {formula.name}: {e}")
            return FormulaEvaluationResult(
                signal=SignalType.HOLD,
                confidence=0.0,
                price=0.0,
                error=str(e)
            )

    async def execute_trade(self, subscription: Subscription, signal: TradeSignal) -> ExecutionResult:
        """
        Execute a trade based on a trading signal.
        
        Args:
            subscription: User subscription
            signal: Trading signal
            
        Returns:
            ExecutionResult with execution details
        """
        try:
            logger.info(f"Executing trade for subscription {subscription.id}")
            
            # Get user's broker account
            broker_account = await self._get_user_broker_account(subscription.user_id)
            if not broker_account:
                return ExecutionResult(
                    success=False,
                    error="No broker account found for user"
                )
            
            # Risk analysis
            risk_warnings = await self._analyze_risk(subscription, signal)
            if risk_warnings and len(risk_warnings) > 0:
                logger.warning(f"Risk warnings for trade: {risk_warnings}")
            
            # Check execution mode
            if subscription.execution_mode == ExecutionMode.MANUAL:
                return ExecutionResult(
                    success=True,
                    requires_approval=True,
                    notification_sent=True,
                    risk_warnings=risk_warnings
                )
            
            elif subscription.execution_mode == ExecutionMode.ALERT_ONLY:
                # Send notification only
                await self.notification_service.send_trade_alert(
                    subscription.user_id,
                    f"Trading signal for {signal.symbol}",
                    f"Signal: {signal.side} at {signal.price}"
                )
                return ExecutionResult(
                    success=True,
                    notification_sent=True,
                    risk_warnings=risk_warnings
                )
            
            # Auto execution
            execution_result = await self._execute_broker_trade(broker_account, signal)
            
            if execution_result["success"]:
                # Create trade record
                trade_id = await self._create_trade_record(subscription, signal, execution_result)
                
                return ExecutionResult(
                    success=True,
                    trade_id=trade_id,
                    execution_price=execution_result["price"],
                    execution_time=execution_result["timestamp"],
                    risk_warnings=risk_warnings
                )
            else:
                return ExecutionResult(
                    success=False,
                    error=execution_result["error"]
                )
                
        except Exception as e:
            logger.error(f"Error executing trade: {e}")
            return ExecutionResult(
                success=False,
                error=str(e)
            )

    async def calculate_performance_metrics(self, formula: Formula, symbol: str) -> Dict[str, Any]:
        """
        Calculate performance metrics for a formula.
        
        Args:
            formula: Formula to analyze
            symbol: Trading symbol
            
        Returns:
            Dictionary with performance metrics
        """
        try:
            # Get historical data
            end_date = datetime.now(timezone.utc)
            start_date = end_date - timedelta(days=30)  # 30 days of data
            
            historical_data = await self.market_data_service.get_historical_data(
                symbol, "1d", start_date, end_date
            )
            
            if not historical_data:
                return {"error": "No historical data available"}
            
            # Calculate metrics
            returns = []
            for i in range(1, len(historical_data)):
                prev_price = historical_data[i-1].get('close', historical_data[i-1].get('price', 0))
                curr_price = historical_data[i].get('close', historical_data[i].get('price', 0))
                if prev_price > 0:
                    daily_return = (curr_price - prev_price) / prev_price
                    returns.append(daily_return)
            
            if not returns:
                return {"error": "Insufficient data for calculations"}
            
            # Calculate performance metrics
            total_return = sum(returns)
            avg_return = sum(returns) / len(returns)
            volatility = (sum((r - avg_return) ** 2 for r in returns) / len(returns)) ** 0.5
            
            # Sharpe ratio (assuming risk-free rate of 0.05)
            risk_free_rate = 0.05 / 252  # Daily risk-free rate
            sharpe_ratio = (avg_return - risk_free_rate) / volatility if volatility > 0 else 0
            
            # Win rate
            winning_days = sum(1 for r in returns if r > 0)
            win_rate = winning_days / len(returns)
            
            return {
                "total_return": total_return,
                "avg_daily_return": avg_return,
                "volatility": volatility,
                "sharpe_ratio": sharpe_ratio,
                "win_rate": win_rate,
                "max_drawdown": self._calculate_max_drawdown(returns),
                "data_points": len(returns)
            }
            
        except Exception as e:
            logger.error(f"Error calculating performance metrics: {e}")
            return {"error": str(e)}

    def validate_formula_code(self, formula_code: str) -> bool:
        """
        Validate formula code syntax and structure.
        
        Args:
            formula_code: JSON string of formula code
            
        Returns:
            True if valid, False otherwise
        """
        try:
            if not formula_code or not formula_code.strip():
                return False
            
            # Parse JSON
            parsed_code = json.loads(formula_code)
            
            # Check required structure
            if not isinstance(parsed_code, dict):
                return False
            
            if "blocks" not in parsed_code or "connections" not in parsed_code:
                return False
            
            # Validate blocks structure
            blocks = parsed_code["blocks"]
            if not isinstance(blocks, list):
                return False
            
            for block in blocks:
                if not isinstance(block, dict):
                    return False
                if "type" not in block or "name" not in block:
                    return False
            
            # Validate connections structure
            connections = parsed_code["connections"]
            if not isinstance(connections, list):
                return False
            
            return True
            
        except (json.JSONDecodeError, KeyError, TypeError):
            return False

    async def cleanup(self) -> None:
        """Clean up resources and close connections."""
        try:
            logger.info("Cleaning up FormulaEngine resources")
            
            # Close any open connections
            if hasattr(self, '_db_session') and self._db_session:
                self._db_session.close()
            
            # Clear caches
            if hasattr(self, '_cache'):
                self._cache.clear()
            
            # Mark cleanup as complete
            self.is_cleanup_complete = True
            logger.info("FormulaEngine cleanup completed")
            
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")
            self.is_cleanup_complete = False

    # Helper methods for the new functionality
    async def _evaluate_formula_logic(self, formula_code: Dict, indicators: Dict, parameters: Dict) -> SignalType:
        """Evaluate formula logic and return signal type."""
        # Mock implementation - in production this would parse and execute the formula
        if 'rsi' in indicators and indicators['rsi'] > 70:
            return SignalType.SELL
        elif 'rsi' in indicators and indicators['rsi'] < 30:
            return SignalType.BUY
        else:
            return SignalType.HOLD

    def _calculate_confidence(self, signal: SignalType, indicators: Dict) -> float:
        """Calculate confidence based on signal strength."""
        if signal == SignalType.HOLD:
            return 0.3  # Lower confidence for hold signals
        elif signal in [SignalType.BUY, SignalType.SELL]:
            return 0.8
        else:
            return 0.6

    def _calculate_risk_levels(self, price: Decimal, parameters: Dict) -> Tuple[Optional[float], Optional[float]]:
        """Calculate stop loss and take profit levels."""
        stop_loss = None
        take_profit = None
        
        if 'stop_loss_percent' in parameters:
            stop_loss = float(price * (1 - parameters['stop_loss_percent'] / 100))
        
        if 'take_profit_percent' in parameters:
            take_profit = float(price * (1 + parameters['take_profit_percent'] / 100))
        
        return stop_loss, take_profit

    def _calculate_position_size(self, price: Decimal, parameters: Dict) -> Optional[int]:
        """Calculate position size based on parameters."""
        if 'position_size' in parameters:
            return int(parameters['position_size'])
        return None

    async def _get_user_broker_account(self, user_id: str) -> Optional[BrokerAccount]:
        """Get user's broker account."""
        db = get_db_session()
        try:
            from uuid import UUID
            # Convert string to UUID if needed
            if isinstance(user_id, str):
                try:
                    user_uuid = UUID(user_id)
                except ValueError:
                    logger.error(f"Invalid UUID format: {user_id}")
                    return None
            else:
                user_uuid = user_id
                
            account = db.query(BrokerAccount).filter(
                BrokerAccount.user_id == user_uuid,
                BrokerAccount.is_active == True
            ).first()
            return account
        finally:
            db.close()

    async def _analyze_risk(self, subscription: Subscription, signal: TradeSignal) -> List[str]:
        """Analyze risk for a trade."""
        warnings = []
        
        # Check position size
        if signal.quantity and signal.quantity > 1000:
            warnings.append("Large position size detected")
        
        # Check stop loss
        if signal.stop_loss and signal.stop_loss > signal.price * 0.95:
            warnings.append("Stop loss too close to entry price")
        
        return warnings

    async def _execute_broker_trade(self, broker_account: BrokerAccount, signal: TradeSignal) -> Dict[str, Any]:
        """Execute trade through broker."""
        # Mock implementation
        return {
            "success": True,
            "price": float(signal.price),
            "timestamp": datetime.now(timezone.utc)
        }

    async def _create_trade_record(self, subscription: Subscription, signal: TradeSignal, execution_result: Dict) -> str:
        """Create trade record in database."""
        db = get_db_session()
        try:
            trade = Trade(
                user_id=subscription.user_id,
                subscription_id=subscription.id,
                symbol=signal.symbol,
                side=signal.side,
                quantity=signal.quantity,
                price=execution_result["price"],
                status="open",
                order_type="market",
                execution_mode=subscription.execution_mode,
                stop_loss=signal.stop_loss,
                take_profit=signal.take_profit,
                execution_price=execution_result["price"],
                execution_time=execution_result["timestamp"]
            )
            db.add(trade)
            db.commit()
            return str(trade.id)
        finally:
            db.close()

    def _calculate_max_drawdown(self, returns: List[float]) -> float:
        """Calculate maximum drawdown from returns."""
        if not returns:
            return 0.0
        
        peak = returns[0]
        max_dd = 0.0
        
        for ret in returns:
            if ret > peak:
                peak = ret
            dd = (peak - ret) / peak
            if dd > max_dd:
                max_dd = dd
        
        return max_dd
