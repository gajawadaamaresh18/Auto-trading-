"""
FormulaEngine - A comprehensive system for evaluating trading formulas and generating signals.

This module provides the FormulaEngine class that:
- Evaluates subscribed formulas for all users at regular intervals
- Generates trading signals (entry/exit) based on market data
- Handles auto-execution and notifications
- Uses async/await for efficient processing
- Integrates with Celery for task scheduling
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass
from enum import Enum
import json
from abc import ABC, abstractmethod

# Celery imports (will be available when celery is installed)
try:
    from celery import Celery
    from celery.schedules import crontab
    CELERY_AVAILABLE = True
except ImportError:
    CELERY_AVAILABLE = False
    # Mock Celery for development
    class Celery:
        def __init__(self, *args, **kwargs):
            pass
        def task(self, *args, **kwargs):
            def decorator(func):
                return func
            return decorator
        def beat_schedule(self, *args, **kwargs):
            pass


class SignalType(Enum):
    """Types of trading signals."""
    ENTRY_LONG = "entry_long"
    ENTRY_SHORT = "entry_short"
    EXIT_LONG = "exit_long"
    EXIT_SHORT = "exit_short"
    HOLD = "hold"


class ExecutionMode(Enum):
    """Execution modes for trading signals."""
    AUTO = "auto"
    NOTIFICATION = "notification"


@dataclass
class MarketData:
    """Market data structure for formula evaluation."""
    symbol: str
    price: float
    volume: int
    timestamp: datetime
    open_price: float
    high_price: float
    low_price: float
    close_price: float
    additional_data: Dict[str, Any] = None

    def __post_init__(self):
        if self.additional_data is None:
            self.additional_data = {}


@dataclass
class TradingSignal:
    """Trading signal generated by formula evaluation."""
    user_id: str
    formula_id: str
    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    price: float
    timestamp: datetime
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class Formula:
    """Trading formula definition."""
    id: str
    user_id: str
    name: str
    code: str
    symbols: List[str]
    is_active: bool = True
    execution_mode: ExecutionMode = ExecutionMode.NOTIFICATION
    created_at: datetime = None
    updated_at: datetime = None

    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        if self.updated_at is None:
            self.updated_at = datetime.now()


class FormulaEvaluator(ABC):
    """Abstract base class for formula evaluators."""
    
    @abstractmethod
    async def evaluate(self, formula: Formula, market_data: Dict[str, MarketData]) -> TradingSignal:
        """Evaluate a formula against market data and return a trading signal."""
        pass


class PythonFormulaEvaluator(FormulaEvaluator):
    """Evaluates Python-based trading formulas."""
    
    def __init__(self, safe_globals: Dict[str, Any] = None):
        self.safe_globals = safe_globals or {
            '__builtins__': {
                'abs': abs, 'min': min, 'max': max, 'sum': sum, 'len': len,
                'round': round, 'int': int, 'float': float, 'str': str,
                'bool': bool, 'list': list, 'dict': dict, 'tuple': tuple,
                'enumerate': enumerate, 'zip': zip, 'range': range,
                'sorted': sorted, 'reversed': reversed, 'hash': hash
            },
            'SignalType': SignalType,
            'datetime': datetime,
            'timedelta': timedelta,
            'math': __import__('math'),
            'numpy': __import__('numpy') if 'numpy' in globals() else None,
            'pandas': __import__('pandas') if 'pandas' in globals() else None,
        }
    
    async def evaluate(self, formula: Formula, market_data: Dict[str, MarketData]) -> TradingSignal:
        """Evaluate a Python formula against market data."""
        try:
            # Create evaluation context
            context = {
                'market_data': market_data,
                'symbols': list(market_data.keys()),
                'current_time': datetime.now(),
                **self.safe_globals
            }
            
            # Execute the formula code
            exec(formula.code, context)
            
            # Extract the result (formula should set 'signal' variable)
            if 'signal' not in context:
                raise ValueError("Formula must set 'signal' variable")
            
            signal_data = context['signal']
            
            # Validate and create signal
            if not isinstance(signal_data, dict):
                raise ValueError("Signal must be a dictionary")
            
            required_fields = ['signal_type', 'confidence', 'price']
            for field in required_fields:
                if field not in signal_data:
                    raise ValueError(f"Signal must contain '{field}' field")
            
            return TradingSignal(
                user_id=formula.user_id,
                formula_id=formula.id,
                symbol=signal_data.get('symbol', list(market_data.keys())[0]),
                signal_type=SignalType(signal_data['signal_type']),
                confidence=float(signal_data['confidence']),
                price=float(signal_data['price']),
                timestamp=datetime.now(),
                metadata=signal_data.get('metadata', {})
            )
            
        except Exception as e:
            logging.error(f"Error evaluating formula {formula.id}: {str(e)}")
            raise


class NotificationService(ABC):
    """Abstract base class for notification services."""
    
    @abstractmethod
    async def send_signal_notification(self, signal: TradingSignal) -> bool:
        """Send a trading signal notification."""
        pass


class EmailNotificationService(NotificationService):
    """Email-based notification service."""
    
    def __init__(self, smtp_config: Dict[str, Any]):
        self.smtp_config = smtp_config
    
    async def send_signal_notification(self, signal: TradingSignal) -> bool:
        """Send email notification for trading signal."""
        try:
            # In a real implementation, this would send an actual email
            logging.info(f"Email notification sent for signal: {signal.signal_type.value} for {signal.symbol}")
            return True
        except Exception as e:
            logging.error(f"Failed to send email notification: {str(e)}")
            return False


class WebhookNotificationService(NotificationService):
    """Webhook-based notification service."""
    
    def __init__(self, webhook_url: str, headers: Dict[str, str] = None):
        self.webhook_url = webhook_url
        self.headers = headers or {}
    
    async def send_signal_notification(self, signal: TradingSignal) -> bool:
        """Send webhook notification for trading signal."""
        try:
            import aiohttp
            async with aiohttp.ClientSession() as session:
                payload = {
                    'user_id': signal.user_id,
                    'formula_id': signal.formula_id,
                    'symbol': signal.symbol,
                    'signal_type': signal.signal_type.value,
                    'confidence': signal.confidence,
                    'price': signal.price,
                    'timestamp': signal.timestamp.isoformat(),
                    'metadata': signal.metadata
                }
                async with session.post(self.webhook_url, json=payload, headers=self.headers) as response:
                    return response.status == 200
        except ImportError:
            logging.error("aiohttp not available for webhook notifications")
            return False
        except Exception as e:
            logging.error(f"Failed to send webhook notification: {str(e)}")
            return False


class TradingExecutor(ABC):
    """Abstract base class for trading execution."""
    
    @abstractmethod
    async def execute_signal(self, signal: TradingSignal) -> bool:
        """Execute a trading signal."""
        pass


class MockTradingExecutor(TradingExecutor):
    """Mock trading executor for testing and development."""
    
    async def execute_signal(self, signal: TradingSignal) -> bool:
        """Mock execution of trading signal."""
        try:
            logging.info(f"Mock execution: {signal.signal_type.value} {signal.symbol} at {signal.price}")
            return True
        except Exception as e:
            logging.error(f"Mock execution failed: {str(e)}")
            return False


class FormulaEngine:
    """
    Main FormulaEngine class for evaluating trading formulas and generating signals.
    
    This class handles:
    - Periodic evaluation of all active formulas for all users
    - Market data fetching and processing
    - Signal generation and validation
    - Auto-execution or notification sending based on user preferences
    - Comprehensive logging and error handling
    """
    
    def __init__(
        self,
        formula_evaluator: FormulaEvaluator = None,
        notification_service: NotificationService = None,
        trading_executor: TradingExecutor = None,
        market_data_provider: Callable[[List[str]], Dict[str, MarketData]] = None,
        user_formula_provider: Callable[[], List[Formula]] = None,
        evaluation_interval: int = 300  # 5 minutes in seconds
    ):
        """
        Initialize the FormulaEngine.
        
        Args:
            formula_evaluator: Evaluator for running formulas
            notification_service: Service for sending notifications
            trading_executor: Executor for auto-trading
            market_data_provider: Function to fetch market data
            user_formula_provider: Function to fetch user formulas
            evaluation_interval: Interval between evaluations in seconds
        """
        self.formula_evaluator = formula_evaluator or PythonFormulaEvaluator()
        self.notification_service = notification_service
        self.trading_executor = trading_executor or MockTradingExecutor()
        self.market_data_provider = market_data_provider or self._default_market_data_provider
        self.user_formula_provider = user_formula_provider or self._default_user_formula_provider
        self.evaluation_interval = evaluation_interval
        
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
        
        # Statistics tracking
        self.stats = {
            'total_evaluations': 0,
            'successful_evaluations': 0,
            'failed_evaluations': 0,
            'signals_generated': 0,
            'auto_executions': 0,
            'notifications_sent': 0,
            'last_evaluation': None
        }
    
    async def _default_market_data_provider(self, symbols: List[str]) -> Dict[str, MarketData]:
        """Default market data provider for testing."""
        # In a real implementation, this would fetch from a market data API
        market_data = {}
        base_price = 100.0
        
        for i, symbol in enumerate(symbols):
            price = base_price + (i * 10) + (hash(symbol) % 20 - 10)
            market_data[symbol] = MarketData(
                symbol=symbol,
                price=price,
                volume=1000000 + (hash(symbol) % 500000),
                timestamp=datetime.now(),
                open_price=price - 0.5,
                high_price=price + 1.0,
                low_price=price - 1.0,
                close_price=price,
                additional_data={'sector': 'technology', 'market_cap': 1000000000}
            )
        
        return market_data
    
    async def _default_user_formula_provider(self) -> List[Formula]:
        """Default user formula provider for testing."""
        # Sample formulas for testing
        formulas = [
            Formula(
                id="formula_1",
                user_id="user_1",
                name="Simple Moving Average Crossover",
                code="""
# Simple moving average crossover strategy
symbol = 'AAPL'
if symbol in market_data:
    data = market_data[symbol]
    # Mock moving average calculation
    ma_short = data.price * 0.98
    ma_long = data.price * 1.02
    
    if ma_short > ma_long:
        signal = {
            'signal_type': 'entry_long',
            'confidence': 0.8,
            'price': data.price,
            'symbol': symbol,
            'metadata': {'ma_short': ma_short, 'ma_long': ma_long}
        }
    else:
        signal = {
            'signal_type': 'hold',
            'confidence': 0.5,
            'price': data.price,
            'symbol': symbol,
            'metadata': {'ma_short': ma_short, 'ma_long': ma_long}
        }
else:
    signal = {
        'signal_type': 'hold',
        'confidence': 0.0,
        'price': 0.0,
        'symbol': 'UNKNOWN',
        'metadata': {'error': 'Symbol not found'}
    }
""",
                symbols=['AAPL', 'GOOGL'],
                execution_mode=ExecutionMode.AUTO
            ),
            Formula(
                id="formula_2",
                user_id="user_2",
                name="Price Breakout Strategy",
                code="""
# Price breakout strategy
symbol = 'GOOGL'
if symbol in market_data:
    data = market_data[symbol]
    # Mock breakout detection
    resistance = data.price * 1.05
    support = data.price * 0.95
    
    if data.price > resistance:
        signal = {
            'signal_type': 'entry_long',
            'confidence': 0.9,
            'price': data.price,
            'symbol': symbol,
            'metadata': {'resistance': resistance, 'support': support}
        }
    elif data.price < support:
        signal = {
            'signal_type': 'entry_short',
            'confidence': 0.7,
            'price': data.price,
            'symbol': symbol,
            'metadata': {'resistance': resistance, 'support': support}
        }
    else:
        signal = {
            'signal_type': 'hold',
            'confidence': 0.3,
            'price': data.price,
            'symbol': symbol,
            'metadata': {'resistance': resistance, 'support': support}
        }
else:
    signal = {
        'signal_type': 'hold',
        'confidence': 0.0,
        'price': 0.0,
        'symbol': 'UNKNOWN',
        'metadata': {'error': 'Symbol not found'}
    }
""",
                symbols=['GOOGL', 'MSFT'],
                execution_mode=ExecutionMode.NOTIFICATION
            )
        ]
        return formulas
    
    async def evaluate_all_formulas(self) -> List[TradingSignal]:
        """
        Evaluate all active formulas for all users and generate signals.
        
        Returns:
            List of generated trading signals
        """
        self.logger.info("Starting formula evaluation cycle")
        self.stats['total_evaluations'] += 1
        self.stats['last_evaluation'] = datetime.now()
        
        signals = []
        
        try:
            # Fetch all active formulas
            formulas = await self.user_formula_provider()
            active_formulas = [f for f in formulas if f.is_active]
            
            if not active_formulas:
                self.logger.info("No active formulas found")
                return signals
            
            # Get all unique symbols from active formulas
            all_symbols = set()
            for formula in active_formulas:
                all_symbols.update(formula.symbols)
            
            # Fetch market data for all symbols
            self.logger.info(f"Fetching market data for {len(all_symbols)} symbols")
            market_data = await self.market_data_provider(list(all_symbols))
            
            # Evaluate each formula
            for formula in active_formulas:
                try:
                    self.logger.info(f"Evaluating formula {formula.id} for user {formula.user_id}")
                    signal = await self.formula_evaluator.evaluate(formula, market_data)
                    signals.append(signal)
                    self.stats['successful_evaluations'] += 1
                    self.stats['signals_generated'] += 1
                    
                    # Process the signal based on execution mode
                    await self._process_signal(signal, formula)
                    
                except Exception as e:
                    self.logger.error(f"Error evaluating formula {formula.id}: {str(e)}")
                    self.stats['failed_evaluations'] += 1
            
            self.logger.info(f"Formula evaluation cycle completed. Generated {len(signals)} signals")
            
        except Exception as e:
            self.logger.error(f"Error in formula evaluation cycle: {str(e)}")
            self.stats['failed_evaluations'] += 1
        
        return signals
    
    async def _process_signal(self, signal: TradingSignal, formula: Formula) -> None:
        """
        Process a generated signal based on the formula's execution mode.
        
        Args:
            signal: The generated trading signal
            formula: The formula that generated the signal
        """
        try:
            if formula.execution_mode == ExecutionMode.AUTO:
                # Auto-execute the signal
                self.logger.info(f"Auto-executing signal: {signal.signal_type.value} for {signal.symbol}")
                success = await self.trading_executor.execute_signal(signal)
                if success:
                    self.stats['auto_executions'] += 1
                    self.logger.info(f"Auto-execution successful for signal {signal.signal_type.value}")
                else:
                    self.logger.error(f"Auto-execution failed for signal {signal.signal_type.value}")
            else:
                # Send notification
                self.logger.info(f"Sending notification for signal: {signal.signal_type.value} for {signal.symbol}")
                if self.notification_service:
                    success = await self.notification_service.send_signal_notification(signal)
                    if success:
                        self.stats['notifications_sent'] += 1
                        self.logger.info(f"Notification sent successfully for signal {signal.signal_type.value}")
                    else:
                        self.logger.error(f"Failed to send notification for signal {signal.signal_type.value}")
                else:
                    self.logger.warning("No notification service configured")
        
        except Exception as e:
            self.logger.error(f"Error processing signal: {str(e)}")
    
    async def start_periodic_evaluation(self) -> None:
        """Start the periodic evaluation process."""
        self.logger.info(f"Starting periodic evaluation every {self.evaluation_interval} seconds")
        
        while True:
            try:
                await self.evaluate_all_formulas()
                await asyncio.sleep(self.evaluation_interval)
            except KeyboardInterrupt:
                self.logger.info("Periodic evaluation stopped by user")
                break
            except Exception as e:
                self.logger.error(f"Error in periodic evaluation: {str(e)}")
                await asyncio.sleep(60)  # Wait 1 minute before retrying
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get current statistics."""
        return self.stats.copy()
    
    def reset_statistics(self) -> None:
        """Reset all statistics."""
        self.stats = {
            'total_evaluations': 0,
            'successful_evaluations': 0,
            'failed_evaluations': 0,
            'signals_generated': 0,
            'auto_executions': 0,
            'notifications_sent': 0,
            'last_evaluation': None
        }


# Celery integration for task scheduling
if CELERY_AVAILABLE:
    # Initialize Celery app
    celery_app = Celery('formula_engine')
    celery_app.conf.update(
        broker_url='redis://localhost:6379/0',
        result_backend='redis://localhost:6379/0',
        task_serializer='json',
        accept_content=['json'],
        result_serializer='json',
        timezone='UTC',
        enable_utc=True,
    )
    
    # Global FormulaEngine instance
    _formula_engine = None
    
    def get_formula_engine() -> FormulaEngine:
        """Get or create the global FormulaEngine instance."""
        global _formula_engine
        if _formula_engine is None:
            _formula_engine = FormulaEngine()
        return _formula_engine
    
    @celery_app.task
    def evaluate_formulas_task():
        """Celery task for evaluating formulas."""
        engine = get_formula_engine()
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(engine.evaluate_all_formulas())
        finally:
            loop.close()
    
    # Schedule periodic evaluation
    celery_app.conf.beat_schedule = {
        'evaluate-formulas-every-5-minutes': {
            'task': 'formula_engine.evaluate_formulas_task',
            'schedule': crontab(minute='*/5'),  # Every 5 minutes
        },
    }
    
    celery_app.conf.timezone = 'UTC'
else:
    # Mock Celery app for development
    celery_app = Celery('formula_engine')


# Example usage and testing functions
async def example_usage():
    """Example usage of the FormulaEngine."""
    # Create notification service
    notification_service = EmailNotificationService({
        'smtp_server': 'smtp.gmail.com',
        'smtp_port': 587,
        'username': 'your_email@gmail.com',
        'password': 'your_password'
    })
    
    # Create FormulaEngine
    engine = FormulaEngine(
        notification_service=notification_service,
        evaluation_interval=60  # 1 minute for testing
    )
    
    # Run a single evaluation cycle
    signals = await engine.evaluate_all_formulas()
    print(f"Generated {len(signals)} signals")
    
    # Print statistics
    stats = engine.get_statistics()
    print(f"Statistics: {stats}")
    
    # Run periodic evaluation (uncomment to run continuously)
    # await engine.start_periodic_evaluation()


if __name__ == "__main__":
    # Run example
    asyncio.run(example_usage())